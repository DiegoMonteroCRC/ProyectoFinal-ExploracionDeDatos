---
title: "Proyecto-Exploracion de Datos"
author: "Luis Diego Montero Vargas"
date: "2025-11-18"
output: html_document
---

# Informacion de datos

Informacion de dataset https://www.kaggle.com/datasets/vivek468/superstore-dataset-final 

Row ID => Unique ID for each row.  
Order ID => Unique Order ID for each Customer.   
Order Date => Order Date of the product.  
Ship Date => Shipping Date of the Product.  
Ship Mode=> Shipping Mode specified by the Customer.  
Customer ID => Unique ID to identify each Customer.  
Customer Name => Name of the Customer.  
Segment => The segment where the Customer belongs.  
Country => Country of residence of the Customer.  
City => City of residence of of the Customer.  
State => State of residence of the Customer.  
Postal Code => Postal Code of every Customer.  
Region => Region where the Customer belong.  
Product ID => Unique ID of the Product.  
Category => Category of the product ordered.  
Sub-Category => Sub-Category of the product ordered.  
Product Name => Name of the Product  
Sales => Sales of the Product.  
Quantity => Quantity of the Product.  
Discount => Discount provided.  
Profit => Profit/Loss incurred.  

# Descripción Completa del Dataset *Sample - Superstore*

El dataset **Sample - Superstore** contiene información detallada sobre transacciones comerciales realizadas por una tienda minorista en Estados Unidos.

Incluye datos sobre ventas, clientes, productos, logística y rentabilidad con un total de 9,994 registros y 21 variables relacionadas con transacciones individuales.

Por lo que para efecto de proyecto se presentara y se expondra un analasis minusioso y critico referente a dicho dataset para una mejor interpretacion y comprension. 

## 1. Estructura General del Dataset

- **Total de filas:** 9,994  
- **Total de columnas:** 21  
- **Valores faltantes:** Ninguno  
- **Tipos de datos presentes:**  

  - Numéricos: `Row ID`, `Sales`, `Quantity`, `Discount`, `Profit`  
  - Fechas (importadas como texto): `Order Date`, `Ship Date`  
  - Categóricos: el resto de columnas  

### Observación
Aunque los datos no contienen valores faltantes, algunas columnas no están en el tipo adecuado para análisis (por ejemplo, fechas como texto y códigos postales como caracteres).

---

## 2. Descripción Detallada de Cada Variable

### 2.1 Identificadores

#### **Row ID**
- Tipo: entero  
- Identificador secuencial de fila  
- **Observación:** No aporta valor analítico. Es redundante, ya que existen otros identificadores más relevantes.

#### **Order ID**
- Identificador del pedido  
- No es único debido a que un pedido puede contener múltiples productos  
- **Observación:** Representa estructura de cabecera-detalle. Necesita agregación para análisis a nivel de pedido.

#### **Order Date**
- Fecha de compra (texto)  
- **Observación:** Requiere conversión a formato fecha para análisis temporal.

#### **Ship Date**
- Fecha de envío del pedido  
- **Observación:** Permite analizar tiempos de despacho una vez convertida a datetime.

#### **Ship Mode**
Categorías posibles:
- *Same Day*  
- *First Class*  
- *Second Class*  
- *Standard Class*  

**Observación:** Útil para análisis logístico, aunque faltan datos de costos de envío o transportistas.

---

### 2.2 Información del Cliente

#### **Customer ID**
- Identificador único del cliente

#### **Customer Name**
- Nombre del cliente  
- **Observación:** Es texto libre; se necesita hacer un procesamiento previo.

#### **Segment**
Categorías:
- Consumer  
- Corporate  
- Home Office  

**Observación:** Segmentación simple basada en tipo de cliente; puede ampliarse para análisis de valor o fidelización.

---

### 2.3 Ubicación Geográfica

Variables incluidas:
- Country  
- City  
- State  
- Postal Code  
- Region  

**Observación:**  
- `Country` no aporta información porque es constante (solo Estados Unidos).  
- `Postal Code` debería normalizarse y ajustarse a tipo numérico para análisis geoespacial.

---

### 2.4 Información del Producto

#### **Product ID**
- Identificador del producto

#### **Category**
Tres categorías principales:

- Furniture  
- Office Supplies  
- Technology  

#### **Sub-Category**
Categorías más específicas como chairs, phones, binders, etc.

#### **Product Name**
- Nombre descriptivo del producto  
- **Observación:** Texto extenso que puede requerir limpieza para análisis como NLP o minería de texto.

---

### 2.5 Métricas de Venta

#### **Sales**
- Monto vendido por línea de pedido  
- Rango aproximado: 0.44 a 22,638  
- **Observación:** Distribución sesgada con valores atípicos altos.

#### **Quantity**
- Cantidad vendida (1 a 14)

#### **Discount**
- Porcentaje de descuento aplicado (0 a 0.8)  
- **Observación:** Descuentos elevados tienden a afectar la rentabilidad de los productos.

#### **Profit**
- Ganancia generada por línea de pedido  
- Promedio: 28.65  
- Mínimo: -6599.98  
- Máximo: 8399.98  
- **Observación:** La existencia de valores altamente negativos indica problemas en la estructura de costos o aplicación de descuentos.

---

## 4. Conclusión

El dataset **Sample - Superstore** es potente y versátil para el estudio y proyecto, sin embargo, requiere pasos previos de limpieza, conversión de tipos y revisión de outliers para obtener análisis más precisos y representativos, por lo que acontinuacion se va a realizar un analisis de los datos y sus variables, para asi justificar y determinar que variables usar y cuales no en el proyecto. 

---



# Carga de librerias

```{r}
library(dplyr)
library(ggplot2)
```



# Analisis del set de datos


### 1. Carga de los datos
```{r}
datos <-read.csv("Sample - Superstore.csv", sep = ",")
```

### 2. Estadisticas basicas

```{r}
head(datos)
```


```{r}
tail(datos)
```

```{r}
summary(datos)
```

```{r}
str(datos)
```

### 3. Validar si existen campos vacios en el dataset


```{r}
colSums(is.na(datos))
```


# Limpieza de datos

### 1. Explicacion del tipo de limpieza a realizar

Sobre todo el set de datos compartido por parte de la empresa se requiere dar un enfoque de los siguientes aspectos.

- Performance por categoría y subcategoría  

- Productos más rentables vs menos rentables  

- Relación entre descuentos y profit  

En este caso no se requieren de muchos de los datos que se encuentran en el dataset, por lo que se procederá a eliminarlos del mismo para crear un dataframe enfocado específicamente en la parte de ventas buscando los resultados propuestos.

El enfoque del proyecto es rentabilidad, categorías, subcategorías, descuentos, ventas, cantidad, profit, y regiones. 

##### **Estas son las columnas que NO aportan nada a este análisis:**

| Columna                              | Motivo para eliminar                                    |
| ------------------------------------ | ------------------------------------------------------- |
| **Row ID**                           | Es solo un índice. No aporta información.               |
| **Order ID**                         | No se analiza rendimiento por orden.                    |
| **Customer ID**                      | No relevante en análisis de rentabilidad general.       |
| **Customer Name**                    | No aporta al análisis.                                  |
| **City**, **State**, **Postal Code** | No se está haciendo análisis geográfico detallado.      |
| **Country**                          | Todos los registros son de USA → no aporta.             |
| **Product ID**                       | No analizamos a nivel SKU, sino categoría/subcategoría. |


##### **Columnas que SI se mantienen**

| Columna                              | Motivo para mantener                                    |
| ------------------------------------ | ------------------------------------------------------- |
| **Order Date**                       | Permite explorar tendencias temporales en ventas, descuentos y                                          profit                                                      |
| **Ship Date**                        | Se decide mantener para apoyar la busqueda de tendencias    |
| **Ship Mode**                        | Puede influir en costos o márgenes, tambien es útil para                                                segmentar resultados en el performance.                     |
| **Segment**                          | Útil para comparar rentabilidad entre segmentos (Consumer,                                              Corporate, Home Office).                                    |
| **Region**                           | Permite comparar performance por región, útil para rentabilidad                                          y tendencias.                                               |
| **Category**                         | Princial variable para análisis de performance              |
| **Sub-Category**                     | Permite identificar subcategorías más o menos rentable      |
| **Product Name**                     | Necesario para identificar productos más rentables vs menos                                             rentables                                                   |
| **Sales**                            | Métrica central para performance y análisis de rentabilidad |
| **Quantity**                         | Permite calcular métricas adicionales como profit por unidad|
| **Discount**                         | Para analizar la relación entre descuentos y profit         |
| **Profit**                           | Clave para evaluar la rentabilidad                          |

### 2. Creacion del dataframe

```{r}
dataframeDatos <- subset(datos, select = -c(Row.ID, Order.ID, Customer.ID, Customer.Name, Country, 
                                            City, State, Postal.Code, Product.ID))
```

Con esto creamos el nuevo dataframe con las columnas necesarias para su análisis

```{r}
head(dataframeDatos)
```


### 3. Conversión de fechas a tipo date


Las variables **Order.Date** y **Ship.Date** actualmente son de tipo character, por lo que se debe pasar a convertir en formato date para su análisis

Formato actual **Order.Date**
```{r}
class(dataframeDatos$Order.Date)
summary(dataframeDatos$Order.Date)
head(dataframeDatos$Order.Date)
```

Formato actual **Ship.Date**
```{r}
class(dataframeDatos$Ship.Date)
summary(dataframeDatos$Ship.Date)
head(dataframeDatos$Ship.Date)
```


Cambio de Order.Date
```{r}
dataframeDatos$Order.Date <- as.Date(dataframeDatos$Order.Date, format = "%m/%d/%Y")
```

```{r}
class(dataframeDatos$Order.Date)
head(dataframeDatos$Order.Date)
```

Cambio de Ship.Date
```{r}
dataframeDatos$Ship.Date <- as.Date(dataframeDatos$Ship.Date, format = "%m/%d/%Y")
```

```{r}
class(dataframeDatos$Ship.Date)
head(dataframeDatos$Ship.Date)
```

### 4. Conversión de datos

```{r}
class(dataframeDatos$Quantity)
```

```{r}
class(dataframeDatos$Discount)
```

```{r}
class(dataframeDatos$Sales)
```

```{r}
class(dataframeDatos$Profit)

```

Como podemos observar en las variables **Sales**, **Profit**, **Quantity**, **Discount** que deberian ser de tipo numerico. En ese caso se procede a convertir todos esos datos a tipo numerico para su análisis apesar de algunos ya esten en ese formato.



```{r}
dataframeDatos$Sales <- as.numeric(dataframeDatos$Sales)
dataframeDatos$Profit <- as.numeric(dataframeDatos$Profit)
dataframeDatos$Quantity <- as.numeric(dataframeDatos$Quantity)
dataframeDatos$Discount <- as.numeric(dataframeDatos$Discount)
```


Validamos los tipos de clase de los datos

```{r}
class(dataframeDatos$Sales)
class(dataframeDatos$Profit)
class(dataframeDatos$Quantity)
class(dataframeDatos$Discount)
```

### Validacion de valores no negativos

En este punto validamos que los valores como **Sales**, **Quantity** y **Discount** no tengan ningún tipo de valor negativo ya que por si naturaleza deben ser siempre ≥ 0

```{r}
summary(dataframeDatos$Sales)
summary(dataframeDatos$Quantity)
summary(dataframeDatos$Discount)
```





boxplot options 


```{r}
dataframeDatos$RangoDescuento <- cut(
  dataframeDatos$Discount,
  breaks = c(-Inf, 0.10, 0.20, 0.50, Inf),
  labels = c('0-10%', '10-20%', '20-50%', '>50%')
)
boxplot(Profit ~ RangoDescuento,
        data = dataframeDatos,
        main = 'Profit por rangos de descuento',
        xlab = 'Rango de descuento',
        ylab = 'Profit',
        col = c('#a1d99b', '#74c476', '#31a354', '#006d2c'),
        ylim = c(-2000, 2000))  # Ajusta según tus datos
```


```{r}
boxplot(Profit ~ RangoDescuento,
        data = dataframeDatos,
        main = 'Profit por rangos de descuento',
        xlab = 'Rango de descuento',
        ylab = 'Profit',
        col = c('#a1d99b', '#74c476', '#31a354', '#006d2c'),
        outline = FALSE)  # No grafica los outliers
```
El boxplot se ve tan comprimido porque hay valores atípicos extremos en tus datos de profit que llegan hasta aproximadamente 7000 y bajan hasta -6000. Cuando R genera el gráfico, necesita incluir todos estos valores en el eje Y, lo que crea una escala muy amplia de alrededor de 13000 unidades. Dentro de esta escala tan grande, las cajas que representan el rango intercuartílico (donde está el 50% central de tus datos) probablemente miden solo unos cientos de unidades, por lo que visualmente se ven como simples líneas horizontales aplastadas.

Cuando quitas los outliers usando `outline = FALSE`, la caja parece volverse mucho más grande y la mediana (esa línea horizontal dentro de la caja) parece moverse, pero en realidad ninguno de estos elementos cambia sus valores numéricos. Lo que sucede es que R automáticamente reescala el eje Y para ajustarse únicamente al rango de los bigotes, que es mucho más pequeño, quizás de -1000 a +1500. La misma caja que antes medía 500 unidades en una escala de 13000 ahora mide esas mismas 500 unidades en una escala de solo 2500, por lo que ocupa proporcionalmente mucho más espacio en el gráfico. Es como hacer zoom a una fotografía: los objetos parecen más grandes pero en realidad mantienen el mismo tamaño, solo cambia la perspectiva desde la que los observas.







cnjdsknvkjdnvjknsdfjnvkjdsnvbfsnvjnds


```{r}
# Boxplot mejorado de Profit por rangos de descuento
boxplot(Sales ~ RangoDescuento,
        data = dataframeDatos,
        main = 'Profit por rangos de descuento',
        xlab = 'Rango de descuento',
        ylab = 'Profit',
        col = c('#a1d99b', '#74c476', '#31a354', '#006d2c'),
        border = "black",
        outline = FALSE
        )

```

En el boxplot sales vs discount, se observa que las ventas más altas se concentran en el rango de descuento más bajo (0-10%), esto sugiere que los productos más demandados no requieren descuentos agresivos para venderse, luego entre 10–20% y 20–50%, las ventas permanecen bajas y estables, sugiere que los descuentos moderados no generan un aumento notable en las ventas, y para los descuentos superiores al 50%, las ventas no aumentan de forma significativa. Se puede concluir, que los descuentos ya sean moderados o altos no tienen un efecto evidente en el aumento de ventas.



```{r}
dataframeDatos %>%
  mutate(RangoDescuento = cut(
    Discount, 
    breaks = c(-Inf, 0.10, 0.20, 0.50, Inf),
    labels = c("0-10%", "10-20%", "20-50%", ">50%")
  )) %>%
  group_by(RangoDescuento) %>%
  summarise(ProfitPromedio = mean(Profit, na.rm = TRUE)) %>%
  ggplot(aes(x = RangoDescuento, y = ProfitPromedio)) +
  geom_col(fill = "#238b45") +
  labs(title = "Profit promedio por rango de descuento")
```

En este gráfico se observa, que el rango de descuento 0–10% es el único claramente rentable, el rango de 10–20% aún mantiene profit promedio positivo, pero considerablemente más bajo, a partir del 20% de descuento, el profit promedio se vuelve negativo y el rango >50% también genera pérdidas significativas. Se comprueba los análisis anteriores, la estrategia de descuentos no está funcionando como palanca comercial positiva, solo está reduciendo la rentabilidad.




# Shapiro 

### Performance por categoría
```{r}
muestra <- sample(dataframeDatos$Sales[dataframeDatos$Category == "Office Supplies"], 5000)
```



```{r}
shapiro.test(dataframeDatos$Sales[dataframeDatos$Category == "Furniture"])
shapiro.test(muestra)
shapiro.test(dataframeDatos$Sales[dataframeDatos$Category == "Technology"])

```



### Performance por subcategoría


```{r}
shapiro.test(dataframeDatos$Sales[dataframeDatos$Sub.Category == "Chairs"])
shapiro.test(dataframeDatos$Sales[dataframeDatos$Sub.Category == "Phones"])
shapiro.test(dataframeDatos$Sales[dataframeDatos$Sub.Category == "Binders"])
shapiro.test(dataframeDatos$Sales[dataframeDatos$Sub.Category == "Storage"])

```

#### Categorías y subcategorías

En todas las categorías y subcategorías el p-value es menor a 0.05.
Esto indica que las ventas no siguen una distribución normal.
La performance es irregular y tiene valores extremos típicos de datos comerciales.




### Productos más rentables vs menos rentables


```{r}
medianProfit <- median(dataframeDatos$Profit)

shapiro.test(dataframeDatos$Profit[dataframeDatos$Profit >= medianProfit])  # más rentables
shapiro.test(dataframeDatos$Profit[dataframeDatos$Profit < medianProfit])   # menos rentables

```


#### Más rentables vs menos rentables

Tanto los productos más rentables como los menos rentables presentan p-value < 0.05.
Por tanto, el profit no es normal en ningún grupo.
Esto muestra que la rentabilidad está muy dispersa y concentrada en pocos productos.


### Relación entre descuentos y profit

```{r}
muestraDiscount <- sample(dataframeDatos$Discount, 5000)
muestraProfit <- sample(dataframeDatos$Profit, 5000)
```

```{r}
shapiro.test(muestraDiscount)
shapiro.test(muestraProfit)
```


Discount

El p-value del Shapiro-Wilk es menor a 0.05, lo que indica que la variable Discount no sigue una distribución normal.
Esto es esperado porque los descuentos suelen concentrarse en intervalos específicos.


Profit

El p-value es menor a 0.05, por lo que Profit no presenta normalidad.
Esto coincide con los datos comerciales, donde hay muchos valores bajos y pocos valores extremos altos o negativos.




